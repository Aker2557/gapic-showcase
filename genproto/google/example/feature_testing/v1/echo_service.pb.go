// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/example/feature_testing/v1/echo_service.proto

/*
Package google_example_feature_testing_v1 is a generated protocol buffer package.

It is generated from these files:
	google/example/feature_testing/v1/echo_service.proto
	google/example/feature_testing/v1/feature_testing_service.proto

It has these top-level messages:
	EchoMessage
	TimeoutTestRequest
	TimeoutTestResponse
	SetupRetryTestRequest
	RetryTestId
	LongrunningTestRequest
	LongrunningTestMetadata
	LongrunningTestResponse
	PaginationTestRequest
	PaginationTestResponse
	ParameterFlatteningTestMessage
	ResourceNameTestMessage
*/
package google_example_feature_testing_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request and response message for the EchoService.
type EchoMessage struct {
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`
}

func (m *EchoMessage) Reset()                    { *m = EchoMessage{} }
func (m *EchoMessage) String() string            { return proto.CompactTextString(m) }
func (*EchoMessage) ProtoMessage()               {}
func (*EchoMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EchoMessage) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func init() {
	proto.RegisterType((*EchoMessage)(nil), "google.example.feature_testing.v1.EchoMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EchoService service

type EchoServiceClient interface {
	// A method used to test unary methods. This method will return the message
	// that was given.
	Echo(ctx context.Context, in *EchoMessage, opts ...grpc.CallOption) (*EchoMessage, error)
	// A method used to test server-side streaming methods. This method will
	// split the given content into words and will pass each word back through
	// the stream.
	Expand(ctx context.Context, in *EchoMessage, opts ...grpc.CallOption) (EchoService_ExpandClient, error)
	// A method used to test client-side streaming methods. This method will
	// collect the contents given to it. When the stream is closed by the client,
	// this method will return the a concatenation of the strings passed to it.
	Collect(ctx context.Context, opts ...grpc.CallOption) (EchoService_CollectClient, error)
	// A method that will be used to test bidirectional streaming methods. Upon
	// receiving a request on the stream, the same content will be passed back
	// on the stream.
	Chat(ctx context.Context, opts ...grpc.CallOption) (EchoService_ChatClient, error)
}

type echoServiceClient struct {
	cc *grpc.ClientConn
}

func NewEchoServiceClient(cc *grpc.ClientConn) EchoServiceClient {
	return &echoServiceClient{cc}
}

func (c *echoServiceClient) Echo(ctx context.Context, in *EchoMessage, opts ...grpc.CallOption) (*EchoMessage, error) {
	out := new(EchoMessage)
	err := grpc.Invoke(ctx, "/google.example.feature_testing.v1.EchoService/Echo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) Expand(ctx context.Context, in *EchoMessage, opts ...grpc.CallOption) (EchoService_ExpandClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[0], c.cc, "/google.example.feature_testing.v1.EchoService/Expand", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceExpandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EchoService_ExpandClient interface {
	Recv() (*EchoMessage, error)
	grpc.ClientStream
}

type echoServiceExpandClient struct {
	grpc.ClientStream
}

func (x *echoServiceExpandClient) Recv() (*EchoMessage, error) {
	m := new(EchoMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) Collect(ctx context.Context, opts ...grpc.CallOption) (EchoService_CollectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[1], c.cc, "/google.example.feature_testing.v1.EchoService/Collect", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceCollectClient{stream}
	return x, nil
}

type EchoService_CollectClient interface {
	Send(*EchoMessage) error
	CloseAndRecv() (*EchoMessage, error)
	grpc.ClientStream
}

type echoServiceCollectClient struct {
	grpc.ClientStream
}

func (x *echoServiceCollectClient) Send(m *EchoMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceCollectClient) CloseAndRecv() (*EchoMessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EchoMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) Chat(ctx context.Context, opts ...grpc.CallOption) (EchoService_ChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[2], c.cc, "/google.example.feature_testing.v1.EchoService/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceChatClient{stream}
	return x, nil
}

type EchoService_ChatClient interface {
	Send(*EchoMessage) error
	Recv() (*EchoMessage, error)
	grpc.ClientStream
}

type echoServiceChatClient struct {
	grpc.ClientStream
}

func (x *echoServiceChatClient) Send(m *EchoMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceChatClient) Recv() (*EchoMessage, error) {
	m := new(EchoMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EchoService service

type EchoServiceServer interface {
	// A method used to test unary methods. This method will return the message
	// that was given.
	Echo(context.Context, *EchoMessage) (*EchoMessage, error)
	// A method used to test server-side streaming methods. This method will
	// split the given content into words and will pass each word back through
	// the stream.
	Expand(*EchoMessage, EchoService_ExpandServer) error
	// A method used to test client-side streaming methods. This method will
	// collect the contents given to it. When the stream is closed by the client,
	// this method will return the a concatenation of the strings passed to it.
	Collect(EchoService_CollectServer) error
	// A method that will be used to test bidirectional streaming methods. Upon
	// receiving a request on the stream, the same content will be passed back
	// on the stream.
	Chat(EchoService_ChatServer) error
}

func RegisterEchoServiceServer(s *grpc.Server, srv EchoServiceServer) {
	s.RegisterService(&_EchoService_serviceDesc, srv)
}

func _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.example.feature_testing.v1.EchoService/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).Echo(ctx, req.(*EchoMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_Expand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EchoMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EchoServiceServer).Expand(m, &echoServiceExpandServer{stream})
}

type EchoService_ExpandServer interface {
	Send(*EchoMessage) error
	grpc.ServerStream
}

type echoServiceExpandServer struct {
	grpc.ServerStream
}

func (x *echoServiceExpandServer) Send(m *EchoMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EchoService_Collect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).Collect(&echoServiceCollectServer{stream})
}

type EchoService_CollectServer interface {
	SendAndClose(*EchoMessage) error
	Recv() (*EchoMessage, error)
	grpc.ServerStream
}

type echoServiceCollectServer struct {
	grpc.ServerStream
}

func (x *echoServiceCollectServer) SendAndClose(m *EchoMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceCollectServer) Recv() (*EchoMessage, error) {
	m := new(EchoMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EchoService_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).Chat(&echoServiceChatServer{stream})
}

type EchoService_ChatServer interface {
	Send(*EchoMessage) error
	Recv() (*EchoMessage, error)
	grpc.ServerStream
}

type echoServiceChatServer struct {
	grpc.ServerStream
}

func (x *echoServiceChatServer) Send(m *EchoMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceChatServer) Recv() (*EchoMessage, error) {
	m := new(EchoMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EchoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.example.feature_testing.v1.EchoService",
	HandlerType: (*EchoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _EchoService_Echo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Expand",
			Handler:       _EchoService_Expand_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Collect",
			Handler:       _EchoService_Collect_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Chat",
			Handler:       _EchoService_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "google/example/feature_testing/v1/echo_service.proto",
}

func init() {
	proto.RegisterFile("google/example/feature_testing/v1/echo_service.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 201 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x32, 0x49, 0xcf, 0xcf, 0x4f,
	0xcf, 0x49, 0xd5, 0x4f, 0xad, 0x48, 0xcc, 0x2d, 0xc8, 0x49, 0xd5, 0x4f, 0x4b, 0x4d, 0x2c, 0x29,
	0x2d, 0x4a, 0x8d, 0x2f, 0x49, 0x2d, 0x2e, 0xc9, 0xcc, 0x4b, 0xd7, 0x2f, 0x33, 0xd4, 0x4f, 0x4d,
	0xce, 0xc8, 0x8f, 0x2f, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9,
	0x17, 0x52, 0x84, 0xe8, 0xd2, 0x83, 0xea, 0xd2, 0x43, 0xd3, 0xa5, 0x57, 0x66, 0xa8, 0xa4, 0xce,
	0xc5, 0xed, 0x9a, 0x9c, 0x91, 0xef, 0x9b, 0x5a, 0x5c, 0x9c, 0x98, 0x9e, 0x2a, 0x24, 0xc1, 0xc5,
	0x9e, 0x9c, 0x9f, 0x57, 0x92, 0x9a, 0x57, 0x22, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x19, 0x04, 0xe3,
	0x1a, 0x1d, 0x62, 0x86, 0xa8, 0x0c, 0x86, 0xd8, 0x20, 0x94, 0xc1, 0xc5, 0x02, 0xe2, 0x0a, 0xe9,
	0xe9, 0x11, 0xb4, 0x44, 0x0f, 0xc9, 0x06, 0x29, 0x12, 0xd5, 0x2b, 0x31, 0x08, 0xe5, 0x70, 0xb1,
	0xb9, 0x56, 0x14, 0x24, 0xe6, 0xa5, 0xd0, 0xde, 0x2e, 0x03, 0x46, 0xa1, 0x5c, 0x2e, 0x76, 0xe7,
	0xfc, 0x9c, 0x9c, 0xd4, 0xe4, 0x12, 0xda, 0x5b, 0xa7, 0xc1, 0x28, 0x94, 0xc3, 0xc5, 0xe2, 0x9c,
	0x91, 0x48, 0x17, 0xbb, 0x0c, 0x18, 0x93, 0xd8, 0xc0, 0xe9, 0xc2, 0x18, 0x10, 0x00, 0x00, 0xff,
	0xff, 0xa9, 0xf1, 0x2e, 0xc4, 0x4f, 0x02, 0x00, 0x00,
}
