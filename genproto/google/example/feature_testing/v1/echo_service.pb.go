// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/example/feature_testing/v1/echo_service.proto

/*
Package google_example_feature_testing_v1 is a generated protocol buffer package.

It is generated from these files:
	google/example/feature_testing/v1/echo_service.proto
	google/example/feature_testing/v1/feature_testing_service.proto

It has these top-level messages:
	EchoRequest
	EchoResponse
	ExpandRequest
	TimeoutTestRequest
	TimeoutTestResponse
	SetupRetryTestRequest
	RetryTestId
	LongrunningTestRequest
	LongrunningTestMetadata
	LongrunningTestResponse
	PaginationTestRequest
	PaginationTestResponse
	ParameterFlatteningTestMessage
	ResourceNameTestMessage
*/
package google_example_feature_testing_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request message used for the Echo, Collect and Chat methods. If content
// is set in this message then the request will succeed. If a status is
type EchoRequest struct {
	// Types that are valid to be assigned to Response:
	//	*EchoRequest_Content
	//	*EchoRequest_Error
	Response isEchoRequest_Response `protobuf_oneof:"response"`
}

func (m *EchoRequest) Reset()                    { *m = EchoRequest{} }
func (m *EchoRequest) String() string            { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()               {}
func (*EchoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isEchoRequest_Response interface {
	isEchoRequest_Response()
}

type EchoRequest_Content struct {
	Content string `protobuf:"bytes,1,opt,name=content,oneof"`
}
type EchoRequest_Error struct {
	Error *google_rpc.Status `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*EchoRequest_Content) isEchoRequest_Response() {}
func (*EchoRequest_Error) isEchoRequest_Response()   {}

func (m *EchoRequest) GetResponse() isEchoRequest_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *EchoRequest) GetContent() string {
	if x, ok := m.GetResponse().(*EchoRequest_Content); ok {
		return x.Content
	}
	return ""
}

func (m *EchoRequest) GetError() *google_rpc.Status {
	if x, ok := m.GetResponse().(*EchoRequest_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EchoRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EchoRequest_OneofMarshaler, _EchoRequest_OneofUnmarshaler, _EchoRequest_OneofSizer, []interface{}{
		(*EchoRequest_Content)(nil),
		(*EchoRequest_Error)(nil),
	}
}

func _EchoRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EchoRequest)
	// response
	switch x := m.Response.(type) {
	case *EchoRequest_Content:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Content)
	case *EchoRequest_Error:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EchoRequest.Response has unexpected type %T", x)
	}
	return nil
}

func _EchoRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EchoRequest)
	switch tag {
	case 1: // response.content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Response = &EchoRequest_Content{x}
		return true, err
	case 2: // response.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_rpc.Status)
		err := b.DecodeMessage(msg)
		m.Response = &EchoRequest_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EchoRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EchoRequest)
	// response
	switch x := m.Response.(type) {
	case *EchoRequest_Content:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Content)))
		n += len(x.Content)
	case *EchoRequest_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The response message for the EchoService methods.
type EchoResponse struct {
	// The content specified in the request.
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`
}

func (m *EchoResponse) Reset()                    { *m = EchoResponse{} }
func (m *EchoResponse) String() string            { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()               {}
func (*EchoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EchoResponse) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// The request message for the Expand method.
type ExpandRequest struct {
	// The content that will be split into words and returned on the stream.
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`
	// The error that is thrown after all words are sent on the stream.
	Error *google_rpc.Status `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *ExpandRequest) Reset()                    { *m = ExpandRequest{} }
func (m *ExpandRequest) String() string            { return proto.CompactTextString(m) }
func (*ExpandRequest) ProtoMessage()               {}
func (*ExpandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExpandRequest) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ExpandRequest) GetError() *google_rpc.Status {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterType((*EchoRequest)(nil), "google.example.feature_testing.v1.EchoRequest")
	proto.RegisterType((*EchoResponse)(nil), "google.example.feature_testing.v1.EchoResponse")
	proto.RegisterType((*ExpandRequest)(nil), "google.example.feature_testing.v1.ExpandRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EchoService service

type EchoServiceClient interface {
	// A method used to test unary methods. This method will return the message
	// that was given.
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// A method used to test server-side streaming methods. This method will
	// split the given content into words and will pass each word back through
	// the stream.
	Expand(ctx context.Context, in *ExpandRequest, opts ...grpc.CallOption) (EchoService_ExpandClient, error)
	// A method used to test client-side streaming methods. This method will
	// collect the contents given to it. When the stream is closed by the client,
	// this method will return the a concatenation of the strings passed to it.
	Collect(ctx context.Context, opts ...grpc.CallOption) (EchoService_CollectClient, error)
	// A method that will be used to test bidirectional streaming methods. Upon
	// receiving a request on the stream, the same content will be passed back
	// on the stream.
	Chat(ctx context.Context, opts ...grpc.CallOption) (EchoService_ChatClient, error)
}

type echoServiceClient struct {
	cc *grpc.ClientConn
}

func NewEchoServiceClient(cc *grpc.ClientConn) EchoServiceClient {
	return &echoServiceClient{cc}
}

func (c *echoServiceClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := grpc.Invoke(ctx, "/google.example.feature_testing.v1.EchoService/Echo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) Expand(ctx context.Context, in *ExpandRequest, opts ...grpc.CallOption) (EchoService_ExpandClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[0], c.cc, "/google.example.feature_testing.v1.EchoService/Expand", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceExpandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EchoService_ExpandClient interface {
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceExpandClient struct {
	grpc.ClientStream
}

func (x *echoServiceExpandClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) Collect(ctx context.Context, opts ...grpc.CallOption) (EchoService_CollectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[1], c.cc, "/google.example.feature_testing.v1.EchoService/Collect", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceCollectClient{stream}
	return x, nil
}

type EchoService_CollectClient interface {
	Send(*EchoRequest) error
	CloseAndRecv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceCollectClient struct {
	grpc.ClientStream
}

func (x *echoServiceCollectClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceCollectClient) CloseAndRecv() (*EchoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) Chat(ctx context.Context, opts ...grpc.CallOption) (EchoService_ChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[2], c.cc, "/google.example.feature_testing.v1.EchoService/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceChatClient{stream}
	return x, nil
}

type EchoService_ChatClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceChatClient struct {
	grpc.ClientStream
}

func (x *echoServiceChatClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceChatClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EchoService service

type EchoServiceServer interface {
	// A method used to test unary methods. This method will return the message
	// that was given.
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
	// A method used to test server-side streaming methods. This method will
	// split the given content into words and will pass each word back through
	// the stream.
	Expand(*ExpandRequest, EchoService_ExpandServer) error
	// A method used to test client-side streaming methods. This method will
	// collect the contents given to it. When the stream is closed by the client,
	// this method will return the a concatenation of the strings passed to it.
	Collect(EchoService_CollectServer) error
	// A method that will be used to test bidirectional streaming methods. Upon
	// receiving a request on the stream, the same content will be passed back
	// on the stream.
	Chat(EchoService_ChatServer) error
}

func RegisterEchoServiceServer(s *grpc.Server, srv EchoServiceServer) {
	s.RegisterService(&_EchoService_serviceDesc, srv)
}

func _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.example.feature_testing.v1.EchoService/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_Expand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExpandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EchoServiceServer).Expand(m, &echoServiceExpandServer{stream})
}

type EchoService_ExpandServer interface {
	Send(*EchoResponse) error
	grpc.ServerStream
}

type echoServiceExpandServer struct {
	grpc.ServerStream
}

func (x *echoServiceExpandServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EchoService_Collect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).Collect(&echoServiceCollectServer{stream})
}

type EchoService_CollectServer interface {
	SendAndClose(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type echoServiceCollectServer struct {
	grpc.ServerStream
}

func (x *echoServiceCollectServer) SendAndClose(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceCollectServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EchoService_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).Chat(&echoServiceChatServer{stream})
}

type EchoService_ChatServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type echoServiceChatServer struct {
	grpc.ServerStream
}

func (x *echoServiceChatServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceChatServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EchoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.example.feature_testing.v1.EchoService",
	HandlerType: (*EchoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _EchoService_Echo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Expand",
			Handler:       _EchoService_Expand_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Collect",
			Handler:       _EchoService_Collect_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Chat",
			Handler:       _EchoService_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "google/example/feature_testing/v1/echo_service.proto",
}

func init() {
	proto.RegisterFile("google/example/feature_testing/v1/echo_service.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 291 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x92, 0xc1, 0x4e, 0x32, 0x31,
	0x14, 0x85, 0xe9, 0xff, 0x23, 0xe8, 0x45, 0x37, 0x77, 0x23, 0x61, 0x85, 0xac, 0x26, 0x2e, 0x5a,
	0x40, 0x9f, 0x40, 0x42, 0xc2, 0x7a, 0xe6, 0x01, 0x48, 0xad, 0xd7, 0x99, 0x49, 0x86, 0xb6, 0xb6,
	0x9d, 0x09, 0x8f, 0xe8, 0x63, 0x19, 0xe9, 0x60, 0x08, 0x89, 0x81, 0xb8, 0x60, 0x79, 0x9b, 0x7b,
	0xee, 0x77, 0xce, 0x49, 0xe1, 0x39, 0x37, 0x26, 0xaf, 0x48, 0xd0, 0x56, 0x6e, 0x6c, 0x45, 0xe2,
	0x9d, 0x64, 0xa8, 0x1d, 0xad, 0x03, 0xf9, 0x50, 0xea, 0x5c, 0x34, 0x33, 0x41, 0xaa, 0x30, 0x6b,
	0x4f, 0xae, 0x29, 0x15, 0x71, 0xeb, 0x4c, 0x30, 0xf8, 0x10, 0x55, 0xbc, 0x55, 0xf1, 0x23, 0x15,
	0x6f, 0x66, 0xa3, 0xfb, 0xf6, 0xb0, 0xb3, 0x4a, 0xf8, 0x20, 0x43, 0xed, 0xa3, 0x76, 0x22, 0x61,
	0xb0, 0x54, 0x85, 0x49, 0xe9, 0xa3, 0x26, 0x1f, 0x70, 0x04, 0x7d, 0x65, 0x74, 0x20, 0x1d, 0x86,
	0x6c, 0xcc, 0x92, 0x9b, 0x55, 0x27, 0xdd, 0x3f, 0xe0, 0x23, 0x5c, 0x91, 0x73, 0xc6, 0x0d, 0xff,
	0x8d, 0x59, 0x32, 0x98, 0x23, 0x6f, 0xb1, 0xce, 0x2a, 0x9e, 0xed, 0x6e, 0xae, 0x3a, 0x69, 0x5c,
	0x79, 0x01, 0xb8, 0x76, 0xe4, 0xad, 0xd1, 0x9e, 0x26, 0x09, 0xdc, 0x46, 0x44, 0x9c, 0x71, 0x78,
	0xc4, 0xf8, 0x21, 0x4c, 0x32, 0xb8, 0x5b, 0x6e, 0xad, 0xd4, 0x6f, 0x7b, 0x3b, 0xbf, 0xae, 0x62,
	0x72, 0xd2, 0x4c, 0x6b, 0x65, 0xfe, 0xf9, 0x3f, 0x46, 0xcc, 0x62, 0x67, 0x58, 0x42, 0xf7, 0x7b,
	0x44, 0xce, 0x4f, 0xd6, 0xc6, 0x0f, 0xaa, 0x19, 0x89, 0xb3, 0xf7, 0xdb, 0xdc, 0x1d, 0x34, 0xd0,
	0x8b, 0x79, 0x70, 0x7a, 0x8e, 0xf8, 0x30, 0xfa, 0x1f, 0x70, 0x53, 0x86, 0x1a, 0xfa, 0x0b, 0x53,
	0x55, 0xa4, 0xc2, 0x05, 0xe2, 0x25, 0x0c, 0x37, 0xd0, 0x5d, 0x14, 0xf2, 0x32, 0xb0, 0x29, 0x7b,
	0xed, 0xed, 0xfe, 0xec, 0xd3, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x78, 0xf9, 0x46, 0x34, 0x27,
	0x03, 0x00, 0x00,
}
